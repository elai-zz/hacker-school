{"name":"Mocky","tagline":"A single parameter pattern matching library in JS","body":"### This is Mocky.\r\nMocky is a small JavaScript library with no external dependencies. Mocky allows you to accomplish pattern matching found in functional programming languages such as ML, Haskell, Erlang, and OCaml in JavaScript. Currently, Mocky is capable of pattern matching with one parameter (see below examples). There are plans in the future to expand, or feel free to contribute. Mocky was tested using the Jasmine testing framework and draws inspiration from another library similar to Mocky, [Funcy](https://github.com/bramstein/funcy).\r\n\r\n### How to use?\r\nSimply include mocky.js in your .html file. \r\n\r\n### Examples\r\n\r\n* Make a new Mocky object and load object with patterns. For `anObj` (below), if you call `anObj(2)`, you'll get `3`. If you call `anObj(3)`, you'll invoke the anonymous function that would call some function `foo()` and return `\"b1\"` as a result from `\"b\" + 1`.  \r\n\r\n```\r\nvar anObj = mocky(\r\n\t[2, 3], \r\n\t[1, 2],\r\n\t[3, function() {\r\n\t\ta = foo();\r\n\t\treturn \"b\" + 1}],\r\n\t[\"apple\", function (n) { return \"I like \" + n}],\r\n        [[\"a\",\"b\",\"c\"],1],\r\n\t[_, \"wow!\"]\r\n);\r\n```\r\n\r\n* You can use Mocky to perform recursion.  \r\n```\r\nvar fact = mocky(\r\n       [0, 1],\r\n       [$, function(n) {return n * fact(n-1)}]\r\n);\r\n\r\nfact(3) // returns 6\r\n```\r\n\r\n* You can use a wildcard character and a param character depending on what you want to do. Like Funcy, Mocky allows you to define your own wildcard and param character. In the example, `_` and `$` were used, respectively. \r\n\r\n```\r\nvar _ = mocky.any;\r\nvar $ = mocky.param;\r\n```\r\n\r\nTo illustrate how these work, refer to the analogy below. If we have in Haskell (we shouldn't because the patterns overlap):\r\n```\r\nfoo _ = 1\r\nfoo n = n + 2\r\n```\r\nWe would represent this in Mocky as such:\r\n```\r\nvar foo = mocky(\r\n       [_, 1],\r\n       [$, function(n) {return n+2;}]\r\n);\r\n```\r\nBut Mocky validates against having both a `mocky.any` and `mocky.param` in an instance and this would actually throw an error.\r\n\r\n* You can also use Mocky to pattern match arrays. \r\n  * You can pattern match on exact array patterns. \r\n  * You can use `mocky.any` to represent any amount of information if **it is placed at the beginning and/or the end**.\r\n  * Likewise, a `mocky.param` at the beginning or end of the pattern represents any amount of information\r\n  * On the other hand, any `mocky.any` or `mocky.param` in the middle of the array represents one element in the array.\r\n\r\n```\r\n// matches exactly [\"a\",\"b\",\"c\",\"d\"]\r\nvar pattern1 = [[\"a\",\"b\",\"c\",\"d\"], 55] \r\n```\r\n```\r\n// matches an array of anything, but doesn't keep the content inside\r\nvar pattern2 = [[_], 55] \r\n```\r\n```\r\n// matches an array of anything, and passes the content to function  \r\nvar pattern3 = [[$], function(n){}]\r\n```\r\n```\r\n// matches an array of anything, and passes the content to 6\r\n// but since 6 isn't function, content is discarded\r\nvar pattern4 = [[$], 6]\r\n```\r\n```\r\n// matches to an array whose content begins with \"a\"\r\nvar pattern5 = [[\"a\",_], 6] \r\n```\r\n```\r\n// matches to an array whose content begins with \"a\"\r\n// the array has at least 3 elements, the second param.any matches to \r\n// the second element only and the third param.any matches the rest\r\nvar pattern6 = [[\"a\",_,_], 6] \r\n```\r\n```\r\n// matches to an array of length 4 beginning with \"a\" \r\n// and ending with \"c\"\r\nvar pattern7 =  [[\"a\",_,_,\"c\"], 6]\r\n```\r\n```\r\n// matches to an array of length at least 4 beginning with anything\r\n// followed by \"b\", an anything and ending with \"c\"\r\nvar pattern8 =  [[_,\"b\",_,\"c\"], 6]  \r\n```\r\n```\r\n// matches to an array of length at least 4 beginning with anything\r\n// followed by \"b\", an anything and ending with \"c\"\r\n// passes all the content up to \"b\" into foo\r\nvar pattern9 =  [[$,\"b\",_,\"c\"], function foo(n){}]  \r\n```\r\n```\r\n// matches to an array of length at least 4 beginning with anything\r\n// followed by \"b\", an anything and ending with \"c\"\r\n// passes the content between \"b\" and \"c\" into foo\r\nvar pattern10 =  [[_,\"b\",$,\"c\"], function foo(n){}]  \r\n```\r\n```\r\n// matches to an array of length at least 4 beginning with anything\r\n// followed by \"b\", an anything and ending with \"c\"\r\n// passes the content up to \"c\" into foo (everything except the last)\r\nvar pattern11 =  [[$,\"c\"], function foo(n){}]  \r\n```\r\n```\r\n// matches to an array whose content begins with \"a\"\r\n// the array has at least 3 elements, the second param.any matches to \r\n// the second element only and the third param.any matches the rest\r\n// passes everything starting from the third element into foo\r\nvar pattern12 = [[\"a\",_,$], function foo(n){}] \r\n```\r\n```\r\n// matches to an array whose content begins with \"a\"\r\n// the array has at least 3 elements, the second param.any matches to \r\n// the second element only and the third param.any matches the rest\r\n// passes the second element into foo \r\nvar pattern13 = [[\"a\",$,_], function foo(n){}] \r\n```\r\n \r\n### Additional Notes:\r\n* Mocky will match an input to the first available pattern, so the order of your patterns matter. \r\n\r\nThis will always return 1 because the wildcard is matched with all inputs.\r\n```\r\nvar bar = mocky(\r\n       [_ , 1],\r\n       [\"a\" , //doSomething]\r\n);\r\n```\r\n\r\n* At this point, Mocky only takes one parameter. A pattern with multiple `mocky.param` is not accepted.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}